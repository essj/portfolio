export class ClientWithAuth {
	transformOptions(options: RequestInit): Promise<RequestInit> {
		options.credentials = "include";

		return new Promise<RequestInit>(resolve => resolve(options));
	}
}

/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import * as moment from 'moment';
import 'moment-duration-format';

export class Client extends ClientWithAuth {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Perform a sign in, user will be authenticated with a cookie if the password matches
     * @param request (optional) 
     * @return Success
     */
    authV1SignIn(request?: SignInRequest | null | undefined): Promise<UserWithPermissionsDto> {
        let url_ = this.baseUrl + "/api/auth/v1/sign-in";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthV1SignIn(_response);
        });
    }

    protected processAuthV1SignIn(response: Response): Promise<UserWithPermissionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithPermissionsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWithPermissionsDto>(<any>null);
    }

    /**
     * Sign in by providing a unique code
     * @param request (optional) 
     * @return Success
     */
    authV1SignInByCode(request?: SignInByCodeRequest | null | undefined): Promise<UserWithPermissionsDto> {
        let url_ = this.baseUrl + "/api/auth/v1/sign-in-by-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthV1SignInByCode(_response);
        });
    }

    protected processAuthV1SignInByCode(response: Response): Promise<UserWithPermissionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithPermissionsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWithPermissionsDto>(<any>null);
    }

    /**
     * Sign out the current user
     * @return Success
     */
    authV1SignOut(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/v1/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthV1SignOut(_response);
        });
    }

    protected processAuthV1SignOut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Parse the given file, replacing the existing jobs with those provided
     */
    jobV1Update(file: FileParameter): Promise<void> {
        let url_ = this.baseUrl + "/api/job/v1/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processJobV1Update(_response);
        });
    }

    protected processJobV1Update(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Record a location.
     * @return Success
     */
    locationV1Record(request: RecordLocationRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/location/v1/record";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLocationV1Record(_response);
        });
    }

    protected processLocationV1Record(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get a list of all message templates
     * @return Success
     */
    messageTemplateV1List(): Promise<MessageTemplateDto[]> {
        let url_ = this.baseUrl + "/api/message-template/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1List(_response);
        });
    }

    protected processMessageTemplateV1List(response: Response): Promise<MessageTemplateDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MessageTemplateDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageTemplateDto[]>(<any>null);
    }

    /**
     * Gets the given MessageTemplate including the variables it supports
     * @return Success
     */
    messageTemplateV1GetById(messageTemplateId: number): Promise<MessageTemplateWithVariablesDto> {
        let url_ = this.baseUrl + "/api/message-template/v1/get/{messageTemplateId}";
        if (messageTemplateId === undefined || messageTemplateId === null)
            throw new Error("The parameter 'messageTemplateId' must be defined.");
        url_ = url_.replace("{messageTemplateId}", encodeURIComponent("" + messageTemplateId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1GetById(_response);
        });
    }

    protected processMessageTemplateV1GetById(response: Response): Promise<MessageTemplateWithVariablesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageTemplateWithVariablesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MessageTemplateWithVariablesDto>(<any>null);
    }

    /**
     * Update the given template to the given value
     * @param update (optional) 
     */
    messageTemplateV1Update(update?: MessageTemplateUpdateDto | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/message-template/v1/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(update);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1Update(_response);
        });
    }

    protected processMessageTemplateV1Update(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Preview what the given template will look like, returns the formatted template
     * @param request (optional) 
     * @return Success
     */
    messageTemplateV1Preview(request?: MessageTemplateUpdateDto | null | undefined): Promise<PreviewResponseDto> {
        let url_ = this.baseUrl + "/api/message-template/v1/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1Preview(_response);
        });
    }

    protected processMessageTemplateV1Preview(response: Response): Promise<PreviewResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PreviewResponseDto>(<any>null);
    }

    /**
     * Send the AheadOfTimeHerdTest email to the current users email address, populated as in the preview
     * @return Success
     */
    messageTemplateV1SendAheadOfTimeHerdTestPreviewAsEmail(): Promise<void> {
        let url_ = this.baseUrl + "/api/message-template/v1/send-ahead-of-time-herd-test-preview-as-email";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1SendAheadOfTimeHerdTestPreviewAsEmail(_response);
        });
    }

    protected processMessageTemplateV1SendAheadOfTimeHerdTestPreviewAsEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send the AheadOfTimeHerdTest email to the current users email address, populated as in the preview
     * @return Success
     */
    messageTemplateV1SendAheadOfTimeHerdTestPreviewAsSms(phoneNumber: string): Promise<void> {
        let url_ = this.baseUrl + "/api/message-template/v1/send-ahead-of-time-herd-test-preview-as-sms?";
        if (phoneNumber === undefined || phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' must be defined and cannot be null.");
        else
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMessageTemplateV1SendAheadOfTimeHerdTestPreviewAsSms(_response);
        });
    }

    protected processMessageTemplateV1SendAheadOfTimeHerdTestPreviewAsSms(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Send the "On Way" notification to all phone numbers for the given job.
    Travel time is calculated from the given location to the shed location
     * @return Success
     */
    notificationV1SendOnWayNotification(request: SendOnWayNotificationRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/notification/v1/send-on-way-notification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotificationV1SendOnWayNotification(_response);
        });
    }

    protected processNotificationV1SendOnWayNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get all the notification log entries on the given date.
     * @param date Date in yyyy-MM-dd format (NSwag can't handle date format in URL).
     * @param type (optional) The type of notification to get. If parameter is not provided, all types will be fetched.
     * @return Success
     */
    notificationLogV1GetLogs(date: string, type?: Type | null | undefined): Promise<NotificationLogDto[]> {
        let url_ = this.baseUrl + "/api/notification-log/v1/logs/{date}?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotificationLogV1GetLogs(_response);
        });
    }

    protected processNotificationLogV1GetLogs(response: Response): Promise<NotificationLogDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationLogDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationLogDto[]>(<any>null);
    }

    /**
     * Fetch all runs that were started within the given time range
     * @return Success
     */
    notificationLogV1GetRuns(from: moment.Moment, to: moment.Moment, notificationRunType: NotificationRunType): Promise<NotificationRunDto[]> {
        let url_ = this.baseUrl + "/api/notification-log/v1/runs?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toJSON() : "") + "&"; 
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toJSON() : "") + "&"; 
        if (notificationRunType === undefined || notificationRunType === null)
            throw new Error("The parameter 'notificationRunType' must be defined and cannot be null.");
        else
            url_ += "notificationRunType=" + encodeURIComponent("" + notificationRunType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotificationLogV1GetRuns(_response);
        });
    }

    protected processNotificationLogV1GetRuns(response: Response): Promise<NotificationRunDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationRunDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationRunDto[]>(<any>null);
    }

    /**
     * Fetch detailed logs for the given run
     * @return Success
     */
    notificationLogV1GetDetailedLogs(notificationRunId: string): Promise<NotificationRunDto> {
        let url_ = this.baseUrl + "/api/notification-log/v1/detailed-logs?";
        if (notificationRunId === undefined || notificationRunId === null)
            throw new Error("The parameter 'notificationRunId' must be defined and cannot be null.");
        else
            url_ += "notificationRunId=" + encodeURIComponent("" + notificationRunId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotificationLogV1GetDetailedLogs(_response);
        });
    }

    protected processNotificationLogV1GetDetailedLogs(response: Response): Promise<NotificationRunDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationRunDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationRunDto>(<any>null);
    }

    /**
     * Generate and return a preview of the ahead of time notifications that will be sent on the given date.
     * @return Success
     */
    notificationLogV1GeneratePreviewForDate(request: NotificationsPreviewRequest): Promise<NotificationsPreviewResponse> {
        let url_ = this.baseUrl + "/api/notification-log/v1/generate-preview-for-date";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processNotificationLogV1GeneratePreviewForDate(_response);
        });
    }

    protected processNotificationLogV1GeneratePreviewForDate(response: Response): Promise<NotificationsPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationsPreviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationsPreviewResponse>(<any>null);
    }

    /**
     * Get the polyline that goes between the given waypoints
     * @param waypoints (optional) 
     * @return Success
     */
    optimiserV1GetPolyline(waypoints?: number[] | null | undefined): Promise<number[][]> {
        let url_ = this.baseUrl + "/api/optimiser/v1/polyline?";
        if (waypoints !== undefined)
            waypoints && waypoints.forEach(item => { url_ += "waypoints=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processOptimiserV1GetPolyline(_response);
        });
    }

    protected processOptimiserV1GetPolyline(response: Response): Promise<number[][]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number[][]>(<any>null);
    }

    /**
     * List all regions in the system.
     * @return Success
     */
    regionV1List(): Promise<RegionDto[]> {
        let url_ = this.baseUrl + "/api/region/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegionV1List(_response);
        });
    }

    protected processRegionV1List(response: Response): Promise<RegionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegionDto[]>(<any>null);
    }

    /**
     * Gets all recorded entrance location information within the given time range.
     * @param startDate The (inclusive) start date of the range to fetch.
     * @param endDate The (inclusive) end date of the range to fetch.
     * @return Success
     */
    reportV1GetEntranceLocations(startDate: string, endDate: string): Promise<FileResult> {
        let url_ = this.baseUrl + "/api/report/v1/entrance-locations?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReportV1GetEntranceLocations(_response);
        });
    }

    protected processReportV1GetEntranceLocations(response: Response): Promise<FileResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResult>(<any>null);
    }

    /**
     * Gets all billing information within the given time range.
     * @param startDate The (inclusive) start date of the range to fetch.
     * @param endDate The (inclusive) end date of the range to fetch.
     * @return Success
     */
    reportV1GetBilling(startDate: string, endDate: string): Promise<BillingDto> {
        let url_ = this.baseUrl + "/api/report/v1/billing?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&"; 
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReportV1GetBilling(_response);
        });
    }

    protected processReportV1GetBilling(response: Response): Promise<BillingDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BillingDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BillingDto>(<any>null);
    }

    /**
     * Returns schedules, optionally with schedule items
     * @param dateStart Date in yyyy-MM-dd format, the (inclusive) start of the range to fetch (NSwag can't handle date format in URL)
     * @param dateEnd Date in yyyy-MM-dd format, the (inclusive) end of the range to fetch (NSwag can't handle date format in URL)
     * @param vehicleIdentifier (optional) Optional - the vehicle to get the schedule for
     * @param includeDetails (optional) If true, fetches the schedule items (default false)
     * @return Success
     */
    scheduleV1Get(dateStart: string, dateEnd: string, vehicleIdentifier?: string | null | undefined, includeDetails?: boolean | null | undefined): Promise<VehicleDayScheduleDto[]> {
        let url_ = this.baseUrl + "/api/schedule/v1/get/{dateStart}/{dateEnd}?";
        if (dateStart === undefined || dateStart === null)
            throw new Error("The parameter 'dateStart' must be defined.");
        url_ = url_.replace("{dateStart}", encodeURIComponent("" + dateStart)); 
        if (dateEnd === undefined || dateEnd === null)
            throw new Error("The parameter 'dateEnd' must be defined.");
        url_ = url_.replace("{dateEnd}", encodeURIComponent("" + dateEnd)); 
        if (vehicleIdentifier !== undefined)
            url_ += "vehicleIdentifier=" + encodeURIComponent("" + vehicleIdentifier) + "&"; 
        if (includeDetails !== undefined)
            url_ += "includeDetails=" + encodeURIComponent("" + includeDetails) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processScheduleV1Get(_response);
        });
    }

    protected processScheduleV1Get(response: Response): Promise<VehicleDayScheduleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleDayScheduleDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleDayScheduleDto[]>(<any>null);
    }

    /**
     * Get a schedule for a vehicle for a given date.
     * @param vehicleIdentifier the vehicle to get the schedule for.
     * @param date Date in yyyy-MM-dd format (NSwag can't handle date format in URL).
     * @return Success
     */
    scheduleV1GetForVehicleByDate(vehicleIdentifier: string, date: string): Promise<VehicleDayScheduleDto> {
        let url_ = this.baseUrl + "/api/schedule/v1/vehicle/{vehicleIdentifier}/{date}";
        if (vehicleIdentifier === undefined || vehicleIdentifier === null)
            throw new Error("The parameter 'vehicleIdentifier' must be defined.");
        url_ = url_.replace("{vehicleIdentifier}", encodeURIComponent("" + vehicleIdentifier)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processScheduleV1GetForVehicleByDate(_response);
        });
    }

    protected processScheduleV1GetForVehicleByDate(response: Response): Promise<VehicleDayScheduleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehicleDayScheduleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleDayScheduleDto>(<any>null);
    }

    /**
     * Update schedules to be confirmed (locked in).
     * @param scheduleIds (optional) The IDs of the schedules to update.
     * @return Success
     */
    scheduleV1UpdateConfirm(scheduleIds?: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/schedule/v1/update/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scheduleIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processScheduleV1UpdateConfirm(_response);
        });
    }

    protected processScheduleV1UpdateConfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get schedule for an assist for a given date.
     * @param userId The ID of the assist user to get the schedule for.
     * @param date The date to get the schedule for.
     * @return Success
     */
    scheduleV1GetForAssistByDate(userId: string, date: string): Promise<AssistDayScheduleDto> {
        let url_ = this.baseUrl + "/api/schedule/v1/assist/{userId}/{date}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processScheduleV1GetForAssistByDate(_response);
        });
    }

    protected processScheduleV1GetForAssistByDate(response: Response): Promise<AssistDayScheduleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssistDayScheduleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssistDayScheduleDto>(<any>null);
    }

    /**
     * Get a list of all of the sheds.
     * @return Success
     */
    shedV1GetByPropertyId(propertyId: number): Promise<ShedDto> {
        let url_ = this.baseUrl + "/api/shed/v1/get/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShedV1GetByPropertyId(_response);
        });
    }

    protected processShedV1GetByPropertyId(response: Response): Promise<ShedDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShedDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShedDto>(<any>null);
    }

    /**
     * Parse the given file and replace the current shed data with the given sheds
     */
    shedV1Update(file: FileParameter): Promise<void> {
        let url_ = this.baseUrl + "/api/shed/v1/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShedV1Update(_response);
        });
    }

    protected processShedV1Update(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Creates a user account and sends a welcome email to the created user
     * @param request (optional) 
     * @return Success
     */
    userV1Add(request?: AddUserRequest | null | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/user/v1/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1Add(_response);
        });
    }

    protected processUserV1Add(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    /**
     * Get a list of all of the users
     * @return Success
     */
    userV1List(): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/user/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1List(_response);
        });
    }

    protected processUserV1List(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(<any>null);
    }

    /**
     * Get the currently signed in user
     * @return Success
     */
    userV1GetMe(): Promise<UserWithPermissionsDto> {
        let url_ = this.baseUrl + "/api/user/v1/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1GetMe(_response);
        });
    }

    protected processUserV1GetMe(response: Response): Promise<UserWithPermissionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithPermissionsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWithPermissionsDto>(<any>null);
    }

    /**
     * Register a user, users require activation (A link will be emailed to them).
    Only for initial boot up of the system
     * @param request (optional) 
     * @return Success
     */
    userV1Register(request?: RegisterRequest | null | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/user/v1/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1Register(_response);
        });
    }

    protected processUserV1Register(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    /**
     * Check if a given token is valid for account activation.
     * @param request (optional) 
     * @return Success
     */
    userV1ActivateValidateToken(request?: ActivateAccountValidateTokenRequest | null | undefined): Promise<ActivateAccountValidateTokenResponse> {
        let url_ = this.baseUrl + "/api/user/v1/activate/validate-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1ActivateValidateToken(_response);
        });
    }

    protected processUserV1ActivateValidateToken(response: Response): Promise<ActivateAccountValidateTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivateAccountValidateTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ActivateAccountValidateTokenResponse>(<any>null);
    }

    /**
     * Activate a user using the details provided in the activation email
     * @param request (optional) 
     * @return Success
     */
    userV1Activate(request?: ActivateRequest | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/v1/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1Activate(_response);
        });
    }

    protected processUserV1Activate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Creates a password reset request for the given email address
     * @param request (optional) 
     * @return Success
     */
    userV1ResetPassword(request?: ResetPasswordRequest | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/v1/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1ResetPassword(_response);
        });
    }

    protected processUserV1ResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Completes a password reset request for the given email address
     * @param request (optional) 
     * @return Success
     */
    userV1ResetPasswordConfirm(request?: ResetPasswordConfirmRequest | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/reset-password/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUserV1ResetPasswordConfirm(_response);
        });
    }

    protected processUserV1ResetPasswordConfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * List all vehicles in the system
     * @return Success
     */
    vehicleV1List(): Promise<VehicleDto[]> {
        let url_ = this.baseUrl + "/api/vehicle/v1/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVehicleV1List(_response);
        });
    }

    protected processVehicleV1List(response: Response): Promise<VehicleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VehicleDto[]>(<any>null);
    }

    /**
     * Parse and geocode the given file, returning a preview of what the resulting values will be
     * @return Success
     */
    vehicleV1Preview(file: FileParameter): Promise<PreviewResponse> {
        let url_ = this.baseUrl + "/api/vehicle/v1/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVehicleV1Preview(_response);
        });
    }

    protected processVehicleV1Preview(response: Response): Promise<PreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PreviewResponse>(<any>null);
    }

    /**
     * Parse and geocode the given file, update the database and return details of what the resulting values are
     * @return Success
     */
    vehicleV1Update(file: FileParameter): Promise<PreviewResponse> {
        let url_ = this.baseUrl + "/api/vehicle/v1/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVehicleV1Update(_response);
        });
    }

    protected processVehicleV1Update(response: Response): Promise<PreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PreviewResponse>(<any>null);
    }
}

/** Required details to sign in */
export class SignInRequest implements ISignInRequest {
    /** Email Address of the user */
    emailAddress!: string;
    /** Password of the user */
    password!: string;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"] !== undefined ? data["emailAddress"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

/** Required details to sign in */
export interface ISignInRequest {
    /** Email Address of the user */
    emailAddress: string;
    /** Password of the user */
    password: string;
}

/** A user with their associated permissions */
export class UserWithPermissionsDto implements IUserWithPermissionsDto {
    /** The user */
    user!: UserDto;
    /** The permissions the user has */
    permissions!: PermissionsDto;

    constructor(data?: IUserWithPermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new UserDto(data.user) : <UserDto>this.user; 
            this.permissions = data.permissions && !(<any>data.permissions).toJSON ? new PermissionsDto(data.permissions) : <PermissionsDto>this.permissions; 
        }
        if (!data) {
            this.user = new UserDto();
            this.permissions = new PermissionsDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserDto.fromJS(data["user"]) : new UserDto();
            this.permissions = data["permissions"] ? PermissionsDto.fromJS(data["permissions"]) : new PermissionsDto();
        }
    }

    static fromJS(data: any): UserWithPermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithPermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["permissions"] = this.permissions ? this.permissions.toJSON() : <any>null;
        return data; 
    }
}

/** A user with their associated permissions */
export interface IUserWithPermissionsDto {
    /** The user */
    user: IUserDto;
    /** The permissions the user has */
    permissions: IPermissionsDto;
}

/** Represents a User */
export class UserDto implements IUserDto {
    /** The users unique ID */
    userId!: string;
    /** The users email address */
    emailAddress!: string;
    /** The type of user */
    userTypes!: UserTypes[];
    /** The vehicle this user is assigned, if any (Only for Vehicle user type) */
    vehicleId!: string | null;
    /** The region this user is assigned, if any (Only for Field user type) */
    regionId!: string | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userTypes = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.emailAddress = data["emailAddress"] !== undefined ? data["emailAddress"] : <any>null;
            if (Array.isArray(data["userTypes"])) {
                this.userTypes = [] as any;
                for (let item of data["userTypes"])
                    this.userTypes!.push(item);
            }
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
            this.regionId = data["regionId"] !== undefined ? data["regionId"] : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        if (Array.isArray(this.userTypes)) {
            data["userTypes"] = [];
            for (let item of this.userTypes)
                data["userTypes"].push(item);
        }
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        return data; 
    }
}

/** Represents a User */
export interface IUserDto {
    /** The users unique ID */
    userId: string;
    /** The users email address */
    emailAddress: string;
    /** The type of user */
    userTypes: UserTypes[];
    /** The vehicle this user is assigned, if any (Only for Vehicle user type) */
    vehicleId: string | null;
    /** The region this user is assigned, if any (Only for Field user type) */
    regionId: string | null;
}

/** Permissions a user has in the system */
export class PermissionsDto implements IPermissionsDto {
    /** Whether this user has access to the optimiser view */
    canViewOptimiser!: boolean;
    /** Whether this user can confirm schedules through the optimiser view */
    canConfirmSchedules!: boolean;
    /** Whether this user can access the vehicle view */
    canUseVehicleView!: boolean;
    /** Whether this user can manage (list/update/add/remove) users */
    canManageUsers!: boolean;
    /** Whether this user can upload a jobs spreadsheet */
    canManageJobs!: boolean;
    /** Whether this user can upload a vehicles spreadsheet */
    canManageVehicles!: boolean;
    /** Whether this user can upload a sites/sheds spreadsheet */
    canManageSites!: boolean;
    /** Whether this user can view sent notifications and edit notification templates */
    canManageNotifications!: boolean;
    /** Whether this user can view and download reports. */
    canManageReports!: boolean;
    /** Whether this user can view billing information. */
    canManageBilling!: boolean;

    constructor(data?: IPermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canViewOptimiser = data["canViewOptimiser"] !== undefined ? data["canViewOptimiser"] : <any>null;
            this.canConfirmSchedules = data["canConfirmSchedules"] !== undefined ? data["canConfirmSchedules"] : <any>null;
            this.canUseVehicleView = data["canUseVehicleView"] !== undefined ? data["canUseVehicleView"] : <any>null;
            this.canManageUsers = data["canManageUsers"] !== undefined ? data["canManageUsers"] : <any>null;
            this.canManageJobs = data["canManageJobs"] !== undefined ? data["canManageJobs"] : <any>null;
            this.canManageVehicles = data["canManageVehicles"] !== undefined ? data["canManageVehicles"] : <any>null;
            this.canManageSites = data["canManageSites"] !== undefined ? data["canManageSites"] : <any>null;
            this.canManageNotifications = data["canManageNotifications"] !== undefined ? data["canManageNotifications"] : <any>null;
            this.canManageReports = data["canManageReports"] !== undefined ? data["canManageReports"] : <any>null;
            this.canManageBilling = data["canManageBilling"] !== undefined ? data["canManageBilling"] : <any>null;
        }
    }

    static fromJS(data: any): PermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canViewOptimiser"] = this.canViewOptimiser !== undefined ? this.canViewOptimiser : <any>null;
        data["canConfirmSchedules"] = this.canConfirmSchedules !== undefined ? this.canConfirmSchedules : <any>null;
        data["canUseVehicleView"] = this.canUseVehicleView !== undefined ? this.canUseVehicleView : <any>null;
        data["canManageUsers"] = this.canManageUsers !== undefined ? this.canManageUsers : <any>null;
        data["canManageJobs"] = this.canManageJobs !== undefined ? this.canManageJobs : <any>null;
        data["canManageVehicles"] = this.canManageVehicles !== undefined ? this.canManageVehicles : <any>null;
        data["canManageSites"] = this.canManageSites !== undefined ? this.canManageSites : <any>null;
        data["canManageNotifications"] = this.canManageNotifications !== undefined ? this.canManageNotifications : <any>null;
        data["canManageReports"] = this.canManageReports !== undefined ? this.canManageReports : <any>null;
        data["canManageBilling"] = this.canManageBilling !== undefined ? this.canManageBilling : <any>null;
        return data; 
    }
}

/** Permissions a user has in the system */
export interface IPermissionsDto {
    /** Whether this user has access to the optimiser view */
    canViewOptimiser: boolean;
    /** Whether this user can confirm schedules through the optimiser view */
    canConfirmSchedules: boolean;
    /** Whether this user can access the vehicle view */
    canUseVehicleView: boolean;
    /** Whether this user can manage (list/update/add/remove) users */
    canManageUsers: boolean;
    /** Whether this user can upload a jobs spreadsheet */
    canManageJobs: boolean;
    /** Whether this user can upload a vehicles spreadsheet */
    canManageVehicles: boolean;
    /** Whether this user can upload a sites/sheds spreadsheet */
    canManageSites: boolean;
    /** Whether this user can view sent notifications and edit notification templates */
    canManageNotifications: boolean;
    /** Whether this user can view and download reports. */
    canManageReports: boolean;
    /** Whether this user can view billing information. */
    canManageBilling: boolean;
}

export class ErrorResponse implements IErrorResponse {
    errors!: string[];

    constructor(data?: IErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.errors = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["errors"])) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IErrorResponse {
    errors: string[];
}

/** Sign in by providing a unique code */
export class SignInByCodeRequest implements ISignInByCodeRequest {
    /** Unique code to allow sign in */
    signInCode!: string;

    constructor(data?: ISignInByCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInCode = data["signInCode"] !== undefined ? data["signInCode"] : <any>null;
        }
    }

    static fromJS(data: any): SignInByCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInByCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInCode"] = this.signInCode !== undefined ? this.signInCode : <any>null;
        return data; 
    }
}

/** Sign in by providing a unique code */
export interface ISignInByCodeRequest {
    /** Unique code to allow sign in */
    signInCode: string;
}

/** Data needed to record a location. */
export class RecordLocationRequest implements IRecordLocationRequest {
    /** The latitude of the location. */
    latitude!: number;
    /** The longitude of the location. */
    longitude!: number;
    /** When this location was recorded by the client. */
    timestamp!: moment.Moment;
    /** The vehicle that recorded this location. */
    vehicleIdentifier!: string;
    /** The shed that this location belongs to. */
    shedId!: number;
    /** The type of the location. */
    locationType!: RecordLocationRequestLocationType;

    constructor(data?: IRecordLocationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.timestamp = data["timestamp"] ? moment(data["timestamp"].toString()) : <any>null;
            this.vehicleIdentifier = data["vehicleIdentifier"] !== undefined ? data["vehicleIdentifier"] : <any>null;
            this.shedId = data["shedId"] !== undefined ? data["shedId"] : <any>null;
            this.locationType = data["locationType"] !== undefined ? data["locationType"] : <any>null;
        }
    }

    static fromJS(data: any): RecordLocationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RecordLocationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>null;
        data["vehicleIdentifier"] = this.vehicleIdentifier !== undefined ? this.vehicleIdentifier : <any>null;
        data["shedId"] = this.shedId !== undefined ? this.shedId : <any>null;
        data["locationType"] = this.locationType !== undefined ? this.locationType : <any>null;
        return data; 
    }
}

/** Data needed to record a location. */
export interface IRecordLocationRequest {
    /** The latitude of the location. */
    latitude: number;
    /** The longitude of the location. */
    longitude: number;
    /** When this location was recorded by the client. */
    timestamp: moment.Moment;
    /** The vehicle that recorded this location. */
    vehicleIdentifier: string;
    /** The shed that this location belongs to. */
    shedId: number;
    /** The type of the location. */
    locationType: RecordLocationRequestLocationType;
}

/** A message template, used by the notification system for messages */
export class MessageTemplateDto implements IMessageTemplateDto {
    /** Unique ID */
    messageTemplateId!: number;
    /** Name of this Template */
    name!: string;
    /** Current value of this template. */
    template!: string;

    constructor(data?: IMessageTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.messageTemplateId = data["messageTemplateId"] !== undefined ? data["messageTemplateId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.template = data["template"] !== undefined ? data["template"] : <any>null;
        }
    }

    static fromJS(data: any): MessageTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageTemplateId"] = this.messageTemplateId !== undefined ? this.messageTemplateId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["template"] = this.template !== undefined ? this.template : <any>null;
        return data; 
    }
}

/** A message template, used by the notification system for messages */
export interface IMessageTemplateDto {
    /** Unique ID */
    messageTemplateId: number;
    /** Name of this Template */
    name: string;
    /** Current value of this template. */
    template: string;
}

/** A message template including the variables that can be used to populate the template */
export class MessageTemplateWithVariablesDto implements IMessageTemplateWithVariablesDto {
    /** The Variables that can be used to populate this template */
    variables!: MessageTemplateVariableDto[];
    /** Unique ID */
    messageTemplateId!: number;
    /** Name of this Template */
    name!: string;
    /** Current value of this template. */
    template!: string;

    constructor(data?: IMessageTemplateWithVariablesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.variables) {
                this.variables = [];
                for (let i = 0; i < data.variables.length; i++) {
                    let item = data.variables[i];
                    this.variables[i] = item && !(<any>item).toJSON ? new MessageTemplateVariableDto(item) : <MessageTemplateVariableDto>item;
                }
            }
        }
        if (!data) {
            this.variables = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["variables"])) {
                this.variables = [] as any;
                for (let item of data["variables"])
                    this.variables!.push(MessageTemplateVariableDto.fromJS(item));
            }
            this.messageTemplateId = data["messageTemplateId"] !== undefined ? data["messageTemplateId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.template = data["template"] !== undefined ? data["template"] : <any>null;
        }
    }

    static fromJS(data: any): MessageTemplateWithVariablesDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageTemplateWithVariablesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.variables)) {
            data["variables"] = [];
            for (let item of this.variables)
                data["variables"].push(item.toJSON());
        }
        data["messageTemplateId"] = this.messageTemplateId !== undefined ? this.messageTemplateId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["template"] = this.template !== undefined ? this.template : <any>null;
        return data; 
    }
}

/** A message template including the variables that can be used to populate the template */
export interface IMessageTemplateWithVariablesDto {
    /** The Variables that can be used to populate this template */
    variables: IMessageTemplateVariableDto[];
    /** Unique ID */
    messageTemplateId: number;
    /** Name of this Template */
    name: string;
    /** Current value of this template. */
    template: string;
}

/** A Variable that can be used to populate a template */
export class MessageTemplateVariableDto implements IMessageTemplateVariableDto {
    /** The variable as it should be used in the template */
    variable!: string;
    /** User readable description of the variable */
    description!: string;
    /** Example value of the variable */
    example!: string;

    constructor(data?: IMessageTemplateVariableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.variable = data["variable"] !== undefined ? data["variable"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
            this.example = data["example"] !== undefined ? data["example"] : <any>null;
        }
    }

    static fromJS(data: any): MessageTemplateVariableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageTemplateVariableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variable"] = this.variable !== undefined ? this.variable : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["example"] = this.example !== undefined ? this.example : <any>null;
        return data; 
    }
}

/** A Variable that can be used to populate a template */
export interface IMessageTemplateVariableDto {
    /** The variable as it should be used in the template */
    variable: string;
    /** User readable description of the variable */
    description: string;
    /** Example value of the variable */
    example: string;
}

/** Variables for formatting a template preview */
export class MessageTemplateUpdateDto implements IMessageTemplateUpdateDto {
    /** Id of the MessageTemplate */
    messageTemplateId!: number;
    /** Template contents to preview */
    template!: string;

    constructor(data?: IMessageTemplateUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.messageTemplateId = data["messageTemplateId"] !== undefined ? data["messageTemplateId"] : <any>null;
            this.template = data["template"] !== undefined ? data["template"] : <any>null;
        }
    }

    static fromJS(data: any): MessageTemplateUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageTemplateUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageTemplateId"] = this.messageTemplateId !== undefined ? this.messageTemplateId : <any>null;
        data["template"] = this.template !== undefined ? this.template : <any>null;
        return data; 
    }
}

/** Variables for formatting a template preview */
export interface IMessageTemplateUpdateDto {
    /** Id of the MessageTemplate */
    messageTemplateId: number;
    /** Template contents to preview */
    template: string;
}

/** Result of Preview */
export class PreviewResponseDto implements IPreviewResponseDto {
    /** Formatted Template */
    preview!: string;

    constructor(data?: IPreviewResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.preview = data["preview"] !== undefined ? data["preview"] : <any>null;
        }
    }

    static fromJS(data: any): PreviewResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preview"] = this.preview !== undefined ? this.preview : <any>null;
        return data; 
    }
}

/** Result of Preview */
export interface IPreviewResponseDto {
    /** Formatted Template */
    preview: string;
}

/** Request to send an "On Way" notification to the contacts for the given job */
export class SendOnWayNotificationRequest implements ISendOnWayNotificationRequest {
    /** The identifier of the job to send notifications for */
    jobId!: string;
    /** The current Latitude of the vehicle */
    currentLatitude!: number;
    /** The current Longitude of the vehicle */
    currentLongitude!: number;

    constructor(data?: ISendOnWayNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobId = data["jobId"] !== undefined ? data["jobId"] : <any>null;
            this.currentLatitude = data["currentLatitude"] !== undefined ? data["currentLatitude"] : <any>null;
            this.currentLongitude = data["currentLongitude"] !== undefined ? data["currentLongitude"] : <any>null;
        }
    }

    static fromJS(data: any): SendOnWayNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendOnWayNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId !== undefined ? this.jobId : <any>null;
        data["currentLatitude"] = this.currentLatitude !== undefined ? this.currentLatitude : <any>null;
        data["currentLongitude"] = this.currentLongitude !== undefined ? this.currentLongitude : <any>null;
        return data; 
    }
}

/** Request to send an "On Way" notification to the contacts for the given job */
export interface ISendOnWayNotificationRequest {
    /** The identifier of the job to send notifications for */
    jobId: string;
    /** The current Latitude of the vehicle */
    currentLatitude: number;
    /** The current Longitude of the vehicle */
    currentLongitude: number;
}

/** Log of an individual notification that has been sent. */
export class NotificationLogDto implements INotificationLogDto {
    /** Unique ID. */
    notificationLogId!: string;
    /** ID of the job this notification is for. */
    jobId!: string | null;
    /** Unique ID from LIC for the related Job, Fulfillment Order + Fulfillment Order Line Number + Transaction Type. */
    jobFO!: string | null;
    /** The vehicle that is associated with the job of this log entry. */
    vehicleIdentifier!: string | null;
    /** ID of the NotificationRun this notification was sent as part of, if any. */
    notificationRunId!: string | null;
    /** Type (reason) of notification. */
    type!: NotificationLogDtoType;
    /** How the notification was sent. */
    method!: NotificationLogDtoMethod;
    /** Time the notification was sent. */
    time!: moment.Moment;
    /** Address (Email Address or Phone Number) the notification was sent to. */
    address!: string;
    /** Email Subject (if notification was an email). */
    subject!: string | null;
    /** Message contents. */
    contents!: string;
    /** The resulting ID that was returned by the NotificationMethod, can be used to look up additional message details in their system. */
    notificationMethodResultId!: string;

    constructor(data?: INotificationLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.notificationLogId = data["notificationLogId"] !== undefined ? data["notificationLogId"] : <any>null;
            this.jobId = data["jobId"] !== undefined ? data["jobId"] : <any>null;
            this.jobFO = data["jobFO"] !== undefined ? data["jobFO"] : <any>null;
            this.vehicleIdentifier = data["vehicleIdentifier"] !== undefined ? data["vehicleIdentifier"] : <any>null;
            this.notificationRunId = data["notificationRunId"] !== undefined ? data["notificationRunId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.method = data["method"] !== undefined ? data["method"] : <any>null;
            this.time = data["time"] ? moment(data["time"].toString()) : <any>null;
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.subject = data["subject"] !== undefined ? data["subject"] : <any>null;
            this.contents = data["contents"] !== undefined ? data["contents"] : <any>null;
            this.notificationMethodResultId = data["notificationMethodResultId"] !== undefined ? data["notificationMethodResultId"] : <any>null;
        }
    }

    static fromJS(data: any): NotificationLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationLogId"] = this.notificationLogId !== undefined ? this.notificationLogId : <any>null;
        data["jobId"] = this.jobId !== undefined ? this.jobId : <any>null;
        data["jobFO"] = this.jobFO !== undefined ? this.jobFO : <any>null;
        data["vehicleIdentifier"] = this.vehicleIdentifier !== undefined ? this.vehicleIdentifier : <any>null;
        data["notificationRunId"] = this.notificationRunId !== undefined ? this.notificationRunId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["method"] = this.method !== undefined ? this.method : <any>null;
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["subject"] = this.subject !== undefined ? this.subject : <any>null;
        data["contents"] = this.contents !== undefined ? this.contents : <any>null;
        data["notificationMethodResultId"] = this.notificationMethodResultId !== undefined ? this.notificationMethodResultId : <any>null;
        return data; 
    }
}

/** Log of an individual notification that has been sent. */
export interface INotificationLogDto {
    /** Unique ID. */
    notificationLogId: string;
    /** ID of the job this notification is for. */
    jobId: string | null;
    /** Unique ID from LIC for the related Job, Fulfillment Order + Fulfillment Order Line Number + Transaction Type. */
    jobFO: string | null;
    /** The vehicle that is associated with the job of this log entry. */
    vehicleIdentifier: string | null;
    /** ID of the NotificationRun this notification was sent as part of, if any. */
    notificationRunId: string | null;
    /** Type (reason) of notification. */
    type: NotificationLogDtoType;
    /** How the notification was sent. */
    method: NotificationLogDtoMethod;
    /** Time the notification was sent. */
    time: moment.Moment;
    /** Address (Email Address or Phone Number) the notification was sent to. */
    address: string;
    /** Email Subject (if notification was an email). */
    subject: string | null;
    /** Message contents. */
    contents: string;
    /** The resulting ID that was returned by the NotificationMethod, can be used to look up additional message details in their system. */
    notificationMethodResultId: string;
}

/** Records a notification service run for a type of notification for one day. */
export class NotificationRunDto implements INotificationRunDto {
    /** Unique ID */
    notificationRunId!: string;
    /** Date that this Notification Run was performed on */
    date!: moment.Moment;
    /** Time that this run started */
    startTime!: moment.Moment;
    /** Time that this run ended, null if in progress or crashed. */
    endTime!: moment.Moment | null;
    /** How many emails were sent */
    emailsSent!: number;
    /** How many SMS messages were sent */
    smsSent!: number;
    /** If these messages were only "Fake Sent" (Not actually sent) */
    fakeSent!: boolean;
    /** Type (reason) of notification. All the logs in this run should be of this type. */
    type!: NotificationRunDtoType;
    /** Logs for this run. */
    logs!: NotificationLogDto[] | null;

    constructor(data?: INotificationRunDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.logs) {
                this.logs = [];
                for (let i = 0; i < data.logs.length; i++) {
                    let item = data.logs[i];
                    this.logs[i] = item && !(<any>item).toJSON ? new NotificationLogDto(item) : <NotificationLogDto>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.notificationRunId = data["notificationRunId"] !== undefined ? data["notificationRunId"] : <any>null;
            this.date = data["date"] ? moment(data["date"].toString()) : <any>null;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>null;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>null;
            this.emailsSent = data["emailsSent"] !== undefined ? data["emailsSent"] : <any>null;
            this.smsSent = data["smsSent"] !== undefined ? data["smsSent"] : <any>null;
            this.fakeSent = data["fakeSent"] !== undefined ? data["fakeSent"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            if (Array.isArray(data["logs"])) {
                this.logs = [] as any;
                for (let item of data["logs"])
                    this.logs!.push(NotificationLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationRunDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRunDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationRunId"] = this.notificationRunId !== undefined ? this.notificationRunId : <any>null;
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>null;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        data["emailsSent"] = this.emailsSent !== undefined ? this.emailsSent : <any>null;
        data["smsSent"] = this.smsSent !== undefined ? this.smsSent : <any>null;
        data["fakeSent"] = this.fakeSent !== undefined ? this.fakeSent : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        if (Array.isArray(this.logs)) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item.toJSON());
        }
        return data; 
    }
}

/** Records a notification service run for a type of notification for one day. */
export interface INotificationRunDto {
    /** Unique ID */
    notificationRunId: string;
    /** Date that this Notification Run was performed on */
    date: moment.Moment;
    /** Time that this run started */
    startTime: moment.Moment;
    /** Time that this run ended, null if in progress or crashed. */
    endTime: moment.Moment | null;
    /** How many emails were sent */
    emailsSent: number;
    /** How many SMS messages were sent */
    smsSent: number;
    /** If these messages were only "Fake Sent" (Not actually sent) */
    fakeSent: boolean;
    /** Type (reason) of notification. All the logs in this run should be of this type. */
    type: NotificationRunDtoType;
    /** Logs for this run. */
    logs: INotificationLogDto[] | null;
}

/** Details for generating the notification preview */
export class NotificationsPreviewRequest implements INotificationsPreviewRequest {
    /** Date that the notifications will be sent on */
    date!: moment.Moment;

    constructor(data?: INotificationsPreviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): NotificationsPreviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationsPreviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>null;
        return data; 
    }
}

/** Details for generating the notification preview */
export interface INotificationsPreviewRequest {
    /** Date that the notifications will be sent on */
    date: moment.Moment;
}

/** Details of a notification preview */
export class NotificationsPreviewResponse implements INotificationsPreviewResponse {
    /** If set then notifications for this date have already been sent, includes the overview of those notifcations. */
    existingRun!: NotificationRunDto | null;
    /** The notifications that will be sent */
    notifications!: NotificationLogDto[];

    constructor(data?: INotificationsPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.existingRun = data.existingRun && !(<any>data.existingRun).toJSON ? new NotificationRunDto(data.existingRun) : <NotificationRunDto>this.existingRun; 
            if (data.notifications) {
                this.notifications = [];
                for (let i = 0; i < data.notifications.length; i++) {
                    let item = data.notifications[i];
                    this.notifications[i] = item && !(<any>item).toJSON ? new NotificationLogDto(item) : <NotificationLogDto>item;
                }
            }
        }
        if (!data) {
            this.notifications = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.existingRun = data["existingRun"] ? NotificationRunDto.fromJS(data["existingRun"]) : <any>null;
            if (Array.isArray(data["notifications"])) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationsPreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationsPreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["existingRun"] = this.existingRun ? this.existingRun.toJSON() : <any>null;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

/** Details of a notification preview */
export interface INotificationsPreviewResponse {
    /** If set then notifications for this date have already been sent, includes the overview of those notifcations. */
    existingRun: INotificationRunDto | null;
    /** The notifications that will be sent */
    notifications: INotificationLogDto[];
}

/** Represents a region that vehicles and jobs belong to. */
export class RegionDto implements IRegionDto {
    /** The unique ID of the region. */
    regionId!: string;
    /** the unique name of the vehicle. */
    name!: string;

    constructor(data?: IRegionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.regionId = data["regionId"] !== undefined ? data["regionId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

/** Represents a region that vehicles and jobs belong to. */
export interface IRegionDto {
    /** The unique ID of the region. */
    regionId: string;
    /** the unique name of the vehicle. */
    name: string;
}

export class FileResult implements IFileResult {
    readonly contentType!: string | null;
    fileDownloadName!: string | null;
    lastModified!: moment.Moment | null;
    entityTag!: EntityTagHeaderValue | null;
    enableRangeProcessing!: boolean | null;

    constructor(data?: IFileResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.entityTag = data.entityTag && !(<any>data.entityTag).toJSON ? new EntityTagHeaderValue(data.entityTag) : <EntityTagHeaderValue>this.entityTag; 
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).contentType = data["contentType"] !== undefined ? data["contentType"] : <any>null;
            this.fileDownloadName = data["fileDownloadName"] !== undefined ? data["fileDownloadName"] : <any>null;
            this.lastModified = data["lastModified"] ? moment(data["lastModified"].toString()) : <any>null;
            this.entityTag = data["entityTag"] ? EntityTagHeaderValue.fromJS(data["entityTag"]) : <any>null;
            this.enableRangeProcessing = data["enableRangeProcessing"] !== undefined ? data["enableRangeProcessing"] : <any>null;
        }
    }

    static fromJS(data: any): FileResult {
        data = typeof data === 'object' ? data : {};
        let result = new FileResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        data["fileDownloadName"] = this.fileDownloadName !== undefined ? this.fileDownloadName : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        data["entityTag"] = this.entityTag ? this.entityTag.toJSON() : <any>null;
        data["enableRangeProcessing"] = this.enableRangeProcessing !== undefined ? this.enableRangeProcessing : <any>null;
        return data; 
    }
}

export interface IFileResult {
    contentType: string | null;
    fileDownloadName: string | null;
    lastModified: moment.Moment | null;
    entityTag: IEntityTagHeaderValue | null;
    enableRangeProcessing: boolean | null;
}

export class EntityTagHeaderValue implements IEntityTagHeaderValue {
    readonly tag!: StringSegment | null;
    readonly isWeak!: boolean | null;

    constructor(data?: IEntityTagHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.tag = data.tag && !(<any>data.tag).toJSON ? new StringSegment(data.tag) : <StringSegment>this.tag; 
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).tag = data["tag"] ? StringSegment.fromJS(data["tag"]) : <any>null;
            (<any>this).isWeak = data["isWeak"] !== undefined ? data["isWeak"] : <any>null;
        }
    }

    static fromJS(data: any): EntityTagHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag"] = this.tag ? this.tag.toJSON() : <any>null;
        data["isWeak"] = this.isWeak !== undefined ? this.isWeak : <any>null;
        return data; 
    }
}

export interface IEntityTagHeaderValue {
    tag: IStringSegment | null;
    isWeak: boolean | null;
}

export class StringSegment implements IStringSegment {
    readonly buffer!: string | null;
    readonly offset!: number | null;
    readonly length!: number | null;
    readonly value!: string | null;
    readonly hasValue!: boolean | null;

    constructor(data?: IStringSegment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).buffer = data["buffer"] !== undefined ? data["buffer"] : <any>null;
            (<any>this).offset = data["offset"] !== undefined ? data["offset"] : <any>null;
            (<any>this).length = data["length"] !== undefined ? data["length"] : <any>null;
            (<any>this).value = data["value"] !== undefined ? data["value"] : <any>null;
            (<any>this).hasValue = data["hasValue"] !== undefined ? data["hasValue"] : <any>null;
        }
    }

    static fromJS(data: any): StringSegment {
        data = typeof data === 'object' ? data : {};
        let result = new StringSegment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buffer"] = this.buffer !== undefined ? this.buffer : <any>null;
        data["offset"] = this.offset !== undefined ? this.offset : <any>null;
        data["length"] = this.length !== undefined ? this.length : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["hasValue"] = this.hasValue !== undefined ? this.hasValue : <any>null;
        return data; 
    }
}

export interface IStringSegment {
    buffer: string | null;
    offset: number | null;
    length: number | null;
    value: string | null;
    hasValue: boolean | null;
}

/** Billing information for a given time period. */
export class BillingDto implements IBillingDto {
    /** The number of sent emails. */
    sentEmails!: number;
    /** The number of sent SMS. */
    sentSms!: number;

    constructor(data?: IBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sentEmails = data["sentEmails"] !== undefined ? data["sentEmails"] : <any>null;
            this.sentSms = data["sentSms"] !== undefined ? data["sentSms"] : <any>null;
        }
    }

    static fromJS(data: any): BillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentEmails"] = this.sentEmails !== undefined ? this.sentEmails : <any>null;
        data["sentSms"] = this.sentSms !== undefined ? this.sentSms : <any>null;
        return data; 
    }
}

/** Billing information for a given time period. */
export interface IBillingDto {
    /** The number of sent emails. */
    sentEmails: number;
    /** The number of sent SMS. */
    sentSms: number;
}

/** What a vehicle will do on a date. */
export class VehicleDayScheduleDto implements IVehicleDayScheduleDto {
    /** The unique ID of this schedule. */
    vehicleDayScheduleId!: string;
    /** The ID of the vehicle this schedule is for. */
    vehicleId!: string;
    /** The date this schedule is for. */
    date!: moment.Moment;
    /** If the jobs on this date for this vehicle have been optimised. */
    isOptimised!: boolean;
    /** If the jobs on this date for this vehicle have been locked in.
No changes should be made to the jobs after the schedule has been locked in. */
    isLockedIn!: boolean;
    /** The location this vehicle is starting from. */
    startLocation!: LocationWithAddressDto;
    /** The location this vehicle is ending its day at. */
    endLocation!: LocationWithAddressDto;
    /** The things this vehicle did on this day in order. */
    schedule!: ScheduleItemDto[];

    constructor(data?: IVehicleDayScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.startLocation = data.startLocation && !(<any>data.startLocation).toJSON ? new LocationWithAddressDto(data.startLocation) : <LocationWithAddressDto>this.startLocation; 
            this.endLocation = data.endLocation && !(<any>data.endLocation).toJSON ? new LocationWithAddressDto(data.endLocation) : <LocationWithAddressDto>this.endLocation; 
            if (data.schedule) {
                this.schedule = [];
                for (let i = 0; i < data.schedule.length; i++) {
                    let item = data.schedule[i];
                    this.schedule[i] = item && !(<any>item).toJSON ? new ScheduleItemDto(item) : <ScheduleItemDto>item;
                }
            }
        }
        if (!data) {
            this.startLocation = new LocationWithAddressDto();
            this.endLocation = new LocationWithAddressDto();
            this.schedule = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.vehicleDayScheduleId = data["vehicleDayScheduleId"] !== undefined ? data["vehicleDayScheduleId"] : <any>null;
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
            this.date = data["date"] ? moment(data["date"].toString()) : <any>null;
            this.isOptimised = data["isOptimised"] !== undefined ? data["isOptimised"] : <any>null;
            this.isLockedIn = data["isLockedIn"] !== undefined ? data["isLockedIn"] : <any>null;
            this.startLocation = data["startLocation"] ? LocationWithAddressDto.fromJS(data["startLocation"]) : new LocationWithAddressDto();
            this.endLocation = data["endLocation"] ? LocationWithAddressDto.fromJS(data["endLocation"]) : new LocationWithAddressDto();
            if (Array.isArray(data["schedule"])) {
                this.schedule = [] as any;
                for (let item of data["schedule"])
                    this.schedule!.push(ScheduleItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehicleDayScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDayScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleDayScheduleId"] = this.vehicleDayScheduleId !== undefined ? this.vehicleDayScheduleId : <any>null;
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>null;
        data["isOptimised"] = this.isOptimised !== undefined ? this.isOptimised : <any>null;
        data["isLockedIn"] = this.isLockedIn !== undefined ? this.isLockedIn : <any>null;
        data["startLocation"] = this.startLocation ? this.startLocation.toJSON() : <any>null;
        data["endLocation"] = this.endLocation ? this.endLocation.toJSON() : <any>null;
        if (Array.isArray(this.schedule)) {
            data["schedule"] = [];
            for (let item of this.schedule)
                data["schedule"].push(item.toJSON());
        }
        return data; 
    }
}

/** What a vehicle will do on a date. */
export interface IVehicleDayScheduleDto {
    /** The unique ID of this schedule. */
    vehicleDayScheduleId: string;
    /** The ID of the vehicle this schedule is for. */
    vehicleId: string;
    /** The date this schedule is for. */
    date: moment.Moment;
    /** If the jobs on this date for this vehicle have been optimised. */
    isOptimised: boolean;
    /** If the jobs on this date for this vehicle have been locked in.
No changes should be made to the jobs after the schedule has been locked in. */
    isLockedIn: boolean;
    /** The location this vehicle is starting from. */
    startLocation: ILocationWithAddressDto;
    /** The location this vehicle is ending its day at. */
    endLocation: ILocationWithAddressDto;
    /** The things this vehicle did on this day in order. */
    schedule: IScheduleItemDto[];
}

/** Represents a Physical Location */
export class LocationWithAddressDto implements ILocationWithAddressDto {
    /** Name of the location */
    address!: string;
    /** Decimal Latitiude WGS84 */
    latitude!: number;
    /** Decimal Longitude WGS84 */
    longitude!: number;

    constructor(data?: ILocationWithAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
        }
    }

    static fromJS(data: any): LocationWithAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationWithAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        return data; 
    }
}

/** Represents a Physical Location */
export interface ILocationWithAddressDto {
    /** Name of the location */
    address: string;
    /** Decimal Latitiude WGS84 */
    latitude: number;
    /** Decimal Longitude WGS84 */
    longitude: number;
}

/** An action a vehicle will take, see child fields for the type */
export class ScheduleItemDto implements IScheduleItemDto {
    /** The time this action was performed at */
    time!: moment.Duration;
    /** Set if this item is a break */
    break!: ScheduledBreakDto | null;
    /** Set if this item is performing a job */
    job!: ScheduledJobDto | null;
    /** Set if this item is travel */
    travel!: ScheduledTravelDto | null;
    /** Set if this item is a wait */
    wait!: ScheduledWaitDto | null;

    constructor(data?: IScheduleItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.break = data.break && !(<any>data.break).toJSON ? new ScheduledBreakDto(data.break) : <ScheduledBreakDto>this.break; 
            this.job = data.job && !(<any>data.job).toJSON ? new ScheduledJobDto(data.job) : <ScheduledJobDto>this.job; 
            this.travel = data.travel && !(<any>data.travel).toJSON ? new ScheduledTravelDto(data.travel) : <ScheduledTravelDto>this.travel; 
            this.wait = data.wait && !(<any>data.wait).toJSON ? new ScheduledWaitDto(data.wait) : <ScheduledWaitDto>this.wait; 
        }
    }

    init(data?: any) {
        if (data) {
            this.time = data["time"] ? moment.duration(data["time"].toString()) : <any>null;
            this.break = data["break"] ? ScheduledBreakDto.fromJS(data["break"]) : <any>null;
            this.job = data["job"] ? ScheduledJobDto.fromJS(data["job"]) : <any>null;
            this.travel = data["travel"] ? ScheduledTravelDto.fromJS(data["travel"]) : <any>null;
            this.wait = data["wait"] ? ScheduledWaitDto.fromJS(data["wait"]) : <any>null;
        }
    }

    static fromJS(data: any): ScheduleItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["break"] = this.break ? this.break.toJSON() : <any>null;
        data["job"] = this.job ? this.job.toJSON() : <any>null;
        data["travel"] = this.travel ? this.travel.toJSON() : <any>null;
        data["wait"] = this.wait ? this.wait.toJSON() : <any>null;
        return data; 
    }
}

/** An action a vehicle will take, see child fields for the type */
export interface IScheduleItemDto {
    /** The time this action was performed at */
    time: moment.Duration;
    /** Set if this item is a break */
    break: IScheduledBreakDto | null;
    /** Set if this item is performing a job */
    job: IScheduledJobDto | null;
    /** Set if this item is travel */
    travel: IScheduledTravelDto | null;
    /** Set if this item is a wait */
    wait: IScheduledWaitDto | null;
}

/** A scheduled break */
export class ScheduledBreakDto implements IScheduledBreakDto {
    /** How long this break is for */
    breakDuration!: moment.Duration;

    constructor(data?: IScheduledBreakDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.breakDuration = data["breakDuration"] ? moment.duration(data["breakDuration"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ScheduledBreakDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledBreakDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["breakDuration"] = this.breakDuration ? this.breakDuration.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        return data; 
    }
}

/** A scheduled break */
export interface IScheduledBreakDto {
    /** How long this break is for */
    breakDuration: moment.Duration;
}

/** A job scheduled to be performed */
export class ScheduledJobDto implements IScheduledJobDto {
    /** Job with full details */
    job!: JobDto;
    /** Hard error: this was a delivery that was performed after a collection */
    readonly deliveryAfterCollection!: boolean;
    /** Hard error: this was visited outside of the Start/End time */
    readonly visitedOutsideCollectionWindow!: boolean;

    constructor(data?: IScheduledJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.job = data.job && !(<any>data.job).toJSON ? new JobDto(data.job) : <JobDto>this.job; 
        }
        if (!data) {
            this.job = new JobDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.job = data["job"] ? JobDto.fromJS(data["job"]) : new JobDto();
            (<any>this).deliveryAfterCollection = data["deliveryAfterCollection"] !== undefined ? data["deliveryAfterCollection"] : <any>null;
            (<any>this).visitedOutsideCollectionWindow = data["visitedOutsideCollectionWindow"] !== undefined ? data["visitedOutsideCollectionWindow"] : <any>null;
        }
    }

    static fromJS(data: any): ScheduledJobDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledJobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["job"] = this.job ? this.job.toJSON() : <any>null;
        data["deliveryAfterCollection"] = this.deliveryAfterCollection !== undefined ? this.deliveryAfterCollection : <any>null;
        data["visitedOutsideCollectionWindow"] = this.visitedOutsideCollectionWindow !== undefined ? this.visitedOutsideCollectionWindow : <any>null;
        return data; 
    }
}

/** A job scheduled to be performed */
export interface IScheduledJobDto {
    /** Job with full details */
    job: IJobDto;
    /** Hard error: this was a delivery that was performed after a collection */
    deliveryAfterCollection: boolean;
    /** Hard error: this was visited outside of the Start/End time */
    visitedOutsideCollectionWindow: boolean;
}

/** A period of travel a vehicle will do */
export class ScheduledTravelDto implements IScheduledTravelDto {
    /** Distance of travel in KM */
    distanceKm!: number;
    /** Time travel is expected to take */
    travelTime!: moment.Duration;

    constructor(data?: IScheduledTravelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.distanceKm = data["distanceKm"] !== undefined ? data["distanceKm"] : <any>null;
            this.travelTime = data["travelTime"] ? moment.duration(data["travelTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ScheduledTravelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledTravelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["distanceKm"] = this.distanceKm !== undefined ? this.distanceKm : <any>null;
        data["travelTime"] = this.travelTime ? this.travelTime.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        return data; 
    }
}

/** A period of travel a vehicle will do */
export interface IScheduledTravelDto {
    /** Distance of travel in KM */
    distanceKm: number;
    /** Time travel is expected to take */
    travelTime: moment.Duration;
}

/** A wait (for job to be available) scheduled */
export class ScheduledWaitDto implements IScheduledWaitDto {
    /** How long this wait is for */
    waitDuration!: moment.Duration;

    constructor(data?: IScheduledWaitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waitDuration = data["waitDuration"] ? moment.duration(data["waitDuration"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ScheduledWaitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduledWaitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waitDuration"] = this.waitDuration ? this.waitDuration.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        return data; 
    }
}

/** A wait (for job to be available) scheduled */
export interface IScheduledWaitDto {
    /** How long this wait is for */
    waitDuration: moment.Duration;
}

/** Represents a job. */
export class JobDto implements IJobDto {
    /** Unique ID for this job. */
    jobId!: string;
    /** The shed associated with this job. */
    shed!: ShedDto;
    /** The identifier of the vehicle associated with this job. */
    vehicleIdentifier!: string;
    /** Whether this job is pickup or delivery. */
    jobType!: JobDtoJobType;
    /** How long performing this job will take */
    jobDuration!: moment.Duration;
    /** The earliest time this job can be started */
    timeWindowStart!: moment.Duration;
    /** The latest time this job can be started */
    timeWindowEnd!: moment.Duration;
    /** Full details of this job. */
    jobDetails!: JobDetailsDto;
    /** Contact details for the farm manager. */
    farmManagerContactDetails!: NotificationContactDto;
    /** Contact details for the primary contact. */
    primaryContactDetails!: NotificationContactDto;

    constructor(data?: IJobDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.shed = data.shed && !(<any>data.shed).toJSON ? new ShedDto(data.shed) : <ShedDto>this.shed; 
            this.jobDetails = data.jobDetails && !(<any>data.jobDetails).toJSON ? new JobDetailsDto(data.jobDetails) : <JobDetailsDto>this.jobDetails; 
            this.farmManagerContactDetails = data.farmManagerContactDetails && !(<any>data.farmManagerContactDetails).toJSON ? new NotificationContactDto(data.farmManagerContactDetails) : <NotificationContactDto>this.farmManagerContactDetails; 
            this.primaryContactDetails = data.primaryContactDetails && !(<any>data.primaryContactDetails).toJSON ? new NotificationContactDto(data.primaryContactDetails) : <NotificationContactDto>this.primaryContactDetails; 
        }
        if (!data) {
            this.shed = new ShedDto();
            this.jobDetails = new JobDetailsDto();
            this.farmManagerContactDetails = new NotificationContactDto();
            this.primaryContactDetails = new NotificationContactDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.jobId = data["jobId"] !== undefined ? data["jobId"] : <any>null;
            this.shed = data["shed"] ? ShedDto.fromJS(data["shed"]) : new ShedDto();
            this.vehicleIdentifier = data["vehicleIdentifier"] !== undefined ? data["vehicleIdentifier"] : <any>null;
            this.jobType = data["jobType"] !== undefined ? data["jobType"] : <any>null;
            this.jobDuration = data["jobDuration"] ? moment.duration(data["jobDuration"].toString()) : <any>null;
            this.timeWindowStart = data["timeWindowStart"] ? moment.duration(data["timeWindowStart"].toString()) : <any>null;
            this.timeWindowEnd = data["timeWindowEnd"] ? moment.duration(data["timeWindowEnd"].toString()) : <any>null;
            this.jobDetails = data["jobDetails"] ? JobDetailsDto.fromJS(data["jobDetails"]) : new JobDetailsDto();
            this.farmManagerContactDetails = data["farmManagerContactDetails"] ? NotificationContactDto.fromJS(data["farmManagerContactDetails"]) : new NotificationContactDto();
            this.primaryContactDetails = data["primaryContactDetails"] ? NotificationContactDto.fromJS(data["primaryContactDetails"]) : new NotificationContactDto();
        }
    }

    static fromJS(data: any): JobDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId !== undefined ? this.jobId : <any>null;
        data["shed"] = this.shed ? this.shed.toJSON() : <any>null;
        data["vehicleIdentifier"] = this.vehicleIdentifier !== undefined ? this.vehicleIdentifier : <any>null;
        data["jobType"] = this.jobType !== undefined ? this.jobType : <any>null;
        data["jobDuration"] = this.jobDuration ? this.jobDuration.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["timeWindowStart"] = this.timeWindowStart ? this.timeWindowStart.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["timeWindowEnd"] = this.timeWindowEnd ? this.timeWindowEnd.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["jobDetails"] = this.jobDetails ? this.jobDetails.toJSON() : <any>null;
        data["farmManagerContactDetails"] = this.farmManagerContactDetails ? this.farmManagerContactDetails.toJSON() : <any>null;
        data["primaryContactDetails"] = this.primaryContactDetails ? this.primaryContactDetails.toJSON() : <any>null;
        return data; 
    }
}

/** Represents a job. */
export interface IJobDto {
    /** Unique ID for this job. */
    jobId: string;
    /** The shed associated with this job. */
    shed: IShedDto;
    /** The identifier of the vehicle associated with this job. */
    vehicleIdentifier: string;
    /** Whether this job is pickup or delivery. */
    jobType: JobDtoJobType;
    /** How long performing this job will take */
    jobDuration: moment.Duration;
    /** The earliest time this job can be started */
    timeWindowStart: moment.Duration;
    /** The latest time this job can be started */
    timeWindowEnd: moment.Duration;
    /** Full details of this job. */
    jobDetails: IJobDetailsDto;
    /** Contact details for the farm manager. */
    farmManagerContactDetails: INotificationContactDto;
    /** Contact details for the primary contact. */
    primaryContactDetails: INotificationContactDto;
}

/** Represents a shed. */
export class ShedDto implements IShedDto {
    /** The unique ID of this shed. */
    shedId!: number;
    /** The unique property ID of this shed. */
    propertyId!: number;
    /** The location of this shed. */
    location!: GpsCoordinate;

    constructor(data?: IShedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.location = data.location && !(<any>data.location).toJSON ? new GpsCoordinate(data.location) : <GpsCoordinate>this.location; 
        }
        if (!data) {
            this.location = new GpsCoordinate();
        }
    }

    init(data?: any) {
        if (data) {
            this.shedId = data["shedId"] !== undefined ? data["shedId"] : <any>null;
            this.propertyId = data["propertyId"] !== undefined ? data["propertyId"] : <any>null;
            this.location = data["location"] ? GpsCoordinate.fromJS(data["location"]) : new GpsCoordinate();
        }
    }

    static fromJS(data: any): ShedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shedId"] = this.shedId !== undefined ? this.shedId : <any>null;
        data["propertyId"] = this.propertyId !== undefined ? this.propertyId : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        return data; 
    }
}

/** Represents a shed. */
export interface IShedDto {
    /** The unique ID of this shed. */
    shedId: number;
    /** The unique property ID of this shed. */
    propertyId: number;
    /** The location of this shed. */
    location: IGpsCoordinate;
}

/** The details as provided by LIC. */
export class JobDetailsDto implements IJobDetailsDto {
    /** Participant code (name id). */
    ptptCode!: string;
    /** Owner Name - Usually a company or persons name. */
    herdName!: string;
    /** Herd Code (Referenced by Lab and AH). */
    herdNumber!: string;
    /** Supply number of the farm. */
    supplyNumber!: number | null;
    /** Address of the house on the farm, usually a useful address. */
    propertyAddress!: string;
    /** Address of the farm, may just be street name. */
    dairyShedEntrance!: string;
    /** Owner contact name. */
    primaryContactName!: string | null;
    /** Owner contact phone number. */
    primaryContactMobile!: string | null;
    /** Type of Dairy Shed. */
    dairyDesign!: string;
    /** Number of Cups. */
    setup!: number;
    /** Text instructions / remarks for setup. */
    instructions!: string;
    /** Text details about hazards on site. */
    hazard!: string | null;
    /** Textual description of how often milking is performed. */
    milkingRegime!: string;
    /** When sampling will be performed. */
    samplingRegime!: JobDetailsDtoSamplingRegime;
    /** Animal Count. */
    estimatedAnimals!: number;
    /** Highest Animal Tag number (Used only for Conventional Testing Herds). */
    highestTagNumber!: number;
    /** Time this farm does its afternoon milking. */
    pmMilkingStartTime!: moment.Duration;
    /** Time this farm does its morning milking. */
    amMilkingStartTime!: moment.Duration;
    /** Collection Method. */
    collectionType!: string;
    /** Number of EZLink devices required (if EZLink test). */
    ezLinkUnits!: number;
    /** Number of EID wands required. */
    eidReaders!: number;
    /** Length of EID wand (if required). */
    eidLength!: string;
    /** Number of Assists required for the test. */
    numberOfAssists!: number;
    /** Name of Assist allocated (if required). */
    assist1Name!: string | null;
    /** The email address of the 1st assist, if any. */
    assist1Email!: string | null;
    /** Name of 2nd Assist allocated (if required). */
    assist2Name!: string | null;
    /** The email address of the 2nd assist, if any. */
    assist2Email!: string | null;
    /** Total number of meters dropped off (including spares). */
    total!: number;
    /** Size of nozzle used in meters provided for the Test. */
    nozzleSize!: string;
    /** Number of trays required to collect samples. */
    sampleTrays!: number;
    /** Number of wash trays. */
    washTrays!: number;
    /** Number of extra trays supplied (if any). */
    spareTrays!: number;
    /** Total number of trays to be delivered. */
    traysTot!: number;
    /** Type of Flask (Standard or Extended). */
    flaskType!: string;
    /** Type of Animal Health Test required (if any). */
    ahTestType!: string | null;
    /** Type of Animal Health Test required (if any).
May be blank if we do not want the person to know. */
    ahNotify!: string | null;
    /** Type of Herd Test. */
    htTestType!: string;
    /** Testing Laboratory (Hamilton Lab or Christchurch Lab). */
    htLab!: string;
    /** Date of First Sample (differs with Sampling Regime). */
    firstSampleDate!: moment.Moment;

    constructor(data?: IJobDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ptptCode = data["ptptCode"] !== undefined ? data["ptptCode"] : <any>null;
            this.herdName = data["herdName"] !== undefined ? data["herdName"] : <any>null;
            this.herdNumber = data["herdNumber"] !== undefined ? data["herdNumber"] : <any>null;
            this.supplyNumber = data["supplyNumber"] !== undefined ? data["supplyNumber"] : <any>null;
            this.propertyAddress = data["propertyAddress"] !== undefined ? data["propertyAddress"] : <any>null;
            this.dairyShedEntrance = data["dairyShedEntrance"] !== undefined ? data["dairyShedEntrance"] : <any>null;
            this.primaryContactName = data["primaryContactName"] !== undefined ? data["primaryContactName"] : <any>null;
            this.primaryContactMobile = data["primaryContactMobile"] !== undefined ? data["primaryContactMobile"] : <any>null;
            this.dairyDesign = data["dairyDesign"] !== undefined ? data["dairyDesign"] : <any>null;
            this.setup = data["setup"] !== undefined ? data["setup"] : <any>null;
            this.instructions = data["instructions"] !== undefined ? data["instructions"] : <any>null;
            this.hazard = data["hazard"] !== undefined ? data["hazard"] : <any>null;
            this.milkingRegime = data["milkingRegime"] !== undefined ? data["milkingRegime"] : <any>null;
            this.samplingRegime = data["samplingRegime"] !== undefined ? data["samplingRegime"] : <any>null;
            this.estimatedAnimals = data["estimatedAnimals"] !== undefined ? data["estimatedAnimals"] : <any>null;
            this.highestTagNumber = data["highestTagNumber"] !== undefined ? data["highestTagNumber"] : <any>null;
            this.pmMilkingStartTime = data["pmMilkingStartTime"] ? moment.duration(data["pmMilkingStartTime"].toString()) : <any>null;
            this.amMilkingStartTime = data["amMilkingStartTime"] ? moment.duration(data["amMilkingStartTime"].toString()) : <any>null;
            this.collectionType = data["collectionType"] !== undefined ? data["collectionType"] : <any>null;
            this.ezLinkUnits = data["ezLinkUnits"] !== undefined ? data["ezLinkUnits"] : <any>null;
            this.eidReaders = data["eidReaders"] !== undefined ? data["eidReaders"] : <any>null;
            this.eidLength = data["eidLength"] !== undefined ? data["eidLength"] : <any>null;
            this.numberOfAssists = data["numberOfAssists"] !== undefined ? data["numberOfAssists"] : <any>null;
            this.assist1Name = data["assist1Name"] !== undefined ? data["assist1Name"] : <any>null;
            this.assist1Email = data["assist1Email"] !== undefined ? data["assist1Email"] : <any>null;
            this.assist2Name = data["assist2Name"] !== undefined ? data["assist2Name"] : <any>null;
            this.assist2Email = data["assist2Email"] !== undefined ? data["assist2Email"] : <any>null;
            this.total = data["total"] !== undefined ? data["total"] : <any>null;
            this.nozzleSize = data["nozzleSize"] !== undefined ? data["nozzleSize"] : <any>null;
            this.sampleTrays = data["sampleTrays"] !== undefined ? data["sampleTrays"] : <any>null;
            this.washTrays = data["washTrays"] !== undefined ? data["washTrays"] : <any>null;
            this.spareTrays = data["spareTrays"] !== undefined ? data["spareTrays"] : <any>null;
            this.traysTot = data["traysTot"] !== undefined ? data["traysTot"] : <any>null;
            this.flaskType = data["flaskType"] !== undefined ? data["flaskType"] : <any>null;
            this.ahTestType = data["ahTestType"] !== undefined ? data["ahTestType"] : <any>null;
            this.ahNotify = data["ahNotify"] !== undefined ? data["ahNotify"] : <any>null;
            this.htTestType = data["htTestType"] !== undefined ? data["htTestType"] : <any>null;
            this.htLab = data["htLab"] !== undefined ? data["htLab"] : <any>null;
            this.firstSampleDate = data["firstSampleDate"] ? moment(data["firstSampleDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): JobDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ptptCode"] = this.ptptCode !== undefined ? this.ptptCode : <any>null;
        data["herdName"] = this.herdName !== undefined ? this.herdName : <any>null;
        data["herdNumber"] = this.herdNumber !== undefined ? this.herdNumber : <any>null;
        data["supplyNumber"] = this.supplyNumber !== undefined ? this.supplyNumber : <any>null;
        data["propertyAddress"] = this.propertyAddress !== undefined ? this.propertyAddress : <any>null;
        data["dairyShedEntrance"] = this.dairyShedEntrance !== undefined ? this.dairyShedEntrance : <any>null;
        data["primaryContactName"] = this.primaryContactName !== undefined ? this.primaryContactName : <any>null;
        data["primaryContactMobile"] = this.primaryContactMobile !== undefined ? this.primaryContactMobile : <any>null;
        data["dairyDesign"] = this.dairyDesign !== undefined ? this.dairyDesign : <any>null;
        data["setup"] = this.setup !== undefined ? this.setup : <any>null;
        data["instructions"] = this.instructions !== undefined ? this.instructions : <any>null;
        data["hazard"] = this.hazard !== undefined ? this.hazard : <any>null;
        data["milkingRegime"] = this.milkingRegime !== undefined ? this.milkingRegime : <any>null;
        data["samplingRegime"] = this.samplingRegime !== undefined ? this.samplingRegime : <any>null;
        data["estimatedAnimals"] = this.estimatedAnimals !== undefined ? this.estimatedAnimals : <any>null;
        data["highestTagNumber"] = this.highestTagNumber !== undefined ? this.highestTagNumber : <any>null;
        data["pmMilkingStartTime"] = this.pmMilkingStartTime ? this.pmMilkingStartTime.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["amMilkingStartTime"] = this.amMilkingStartTime ? this.amMilkingStartTime.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["collectionType"] = this.collectionType !== undefined ? this.collectionType : <any>null;
        data["ezLinkUnits"] = this.ezLinkUnits !== undefined ? this.ezLinkUnits : <any>null;
        data["eidReaders"] = this.eidReaders !== undefined ? this.eidReaders : <any>null;
        data["eidLength"] = this.eidLength !== undefined ? this.eidLength : <any>null;
        data["numberOfAssists"] = this.numberOfAssists !== undefined ? this.numberOfAssists : <any>null;
        data["assist1Name"] = this.assist1Name !== undefined ? this.assist1Name : <any>null;
        data["assist1Email"] = this.assist1Email !== undefined ? this.assist1Email : <any>null;
        data["assist2Name"] = this.assist2Name !== undefined ? this.assist2Name : <any>null;
        data["assist2Email"] = this.assist2Email !== undefined ? this.assist2Email : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["nozzleSize"] = this.nozzleSize !== undefined ? this.nozzleSize : <any>null;
        data["sampleTrays"] = this.sampleTrays !== undefined ? this.sampleTrays : <any>null;
        data["washTrays"] = this.washTrays !== undefined ? this.washTrays : <any>null;
        data["spareTrays"] = this.spareTrays !== undefined ? this.spareTrays : <any>null;
        data["traysTot"] = this.traysTot !== undefined ? this.traysTot : <any>null;
        data["flaskType"] = this.flaskType !== undefined ? this.flaskType : <any>null;
        data["ahTestType"] = this.ahTestType !== undefined ? this.ahTestType : <any>null;
        data["ahNotify"] = this.ahNotify !== undefined ? this.ahNotify : <any>null;
        data["htTestType"] = this.htTestType !== undefined ? this.htTestType : <any>null;
        data["htLab"] = this.htLab !== undefined ? this.htLab : <any>null;
        data["firstSampleDate"] = this.firstSampleDate ? this.firstSampleDate.toISOString() : <any>null;
        return data; 
    }
}

/** The details as provided by LIC. */
export interface IJobDetailsDto {
    /** Participant code (name id). */
    ptptCode: string;
    /** Owner Name - Usually a company or persons name. */
    herdName: string;
    /** Herd Code (Referenced by Lab and AH). */
    herdNumber: string;
    /** Supply number of the farm. */
    supplyNumber: number | null;
    /** Address of the house on the farm, usually a useful address. */
    propertyAddress: string;
    /** Address of the farm, may just be street name. */
    dairyShedEntrance: string;
    /** Owner contact name. */
    primaryContactName: string | null;
    /** Owner contact phone number. */
    primaryContactMobile: string | null;
    /** Type of Dairy Shed. */
    dairyDesign: string;
    /** Number of Cups. */
    setup: number;
    /** Text instructions / remarks for setup. */
    instructions: string;
    /** Text details about hazards on site. */
    hazard: string | null;
    /** Textual description of how often milking is performed. */
    milkingRegime: string;
    /** When sampling will be performed. */
    samplingRegime: JobDetailsDtoSamplingRegime;
    /** Animal Count. */
    estimatedAnimals: number;
    /** Highest Animal Tag number (Used only for Conventional Testing Herds). */
    highestTagNumber: number;
    /** Time this farm does its afternoon milking. */
    pmMilkingStartTime: moment.Duration;
    /** Time this farm does its morning milking. */
    amMilkingStartTime: moment.Duration;
    /** Collection Method. */
    collectionType: string;
    /** Number of EZLink devices required (if EZLink test). */
    ezLinkUnits: number;
    /** Number of EID wands required. */
    eidReaders: number;
    /** Length of EID wand (if required). */
    eidLength: string;
    /** Number of Assists required for the test. */
    numberOfAssists: number;
    /** Name of Assist allocated (if required). */
    assist1Name: string | null;
    /** The email address of the 1st assist, if any. */
    assist1Email: string | null;
    /** Name of 2nd Assist allocated (if required). */
    assist2Name: string | null;
    /** The email address of the 2nd assist, if any. */
    assist2Email: string | null;
    /** Total number of meters dropped off (including spares). */
    total: number;
    /** Size of nozzle used in meters provided for the Test. */
    nozzleSize: string;
    /** Number of trays required to collect samples. */
    sampleTrays: number;
    /** Number of wash trays. */
    washTrays: number;
    /** Number of extra trays supplied (if any). */
    spareTrays: number;
    /** Total number of trays to be delivered. */
    traysTot: number;
    /** Type of Flask (Standard or Extended). */
    flaskType: string;
    /** Type of Animal Health Test required (if any). */
    ahTestType: string | null;
    /** Type of Animal Health Test required (if any).
May be blank if we do not want the person to know. */
    ahNotify: string | null;
    /** Type of Herd Test. */
    htTestType: string;
    /** Testing Laboratory (Hamilton Lab or Christchurch Lab). */
    htLab: string;
    /** Date of First Sample (differs with Sampling Regime). */
    firstSampleDate: moment.Moment;
}

/** Details of someone that will receive pre-visit notifications */
export class NotificationContactDto implements INotificationContactDto {
    /** Phone number in E.164 format of the contact.
Will be sent before and on way notifications.
Empty if no SMS to be sent. */
    phoneNumber!: string | null;
    /** Email address of the contact.
Will be sent before notifications.
Empty if no email to be sent. */
    email!: string | null;
    /** Name of the contact. */
    name!: string | null;

    constructor(data?: INotificationContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): NotificationContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

/** Details of someone that will receive pre-visit notifications */
export interface INotificationContactDto {
    /** Phone number in E.164 format of the contact.
Will be sent before and on way notifications.
Empty if no SMS to be sent. */
    phoneNumber: string | null;
    /** Email address of the contact.
Will be sent before notifications.
Empty if no email to be sent. */
    email: string | null;
    /** Name of the contact. */
    name: string | null;
}

export class GpsCoordinate implements IGpsCoordinate {
    longitude!: number;
    latitude!: number;

    constructor(data?: IGpsCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
        }
    }

    static fromJS(data: any): GpsCoordinate {
        data = typeof data === 'object' ? data : {};
        let result = new GpsCoordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        return data; 
    }
}

export interface IGpsCoordinate {
    longitude: number;
    latitude: number;
}

/** Jobs for an assist on one day. */
export class AssistDayScheduleDto implements IAssistDayScheduleDto {
    /** The date this schedule is for. */
    date!: moment.Moment;
    /** AM job with full details. */
    amJob!: JobDto | null;
    /** PM job with full details. */
    pmJob!: JobDto | null;
    /** If this schedule has a conflict, e.g. more than two jobs a day or more than one job per time (AM/PM). */
    hasConflict!: boolean;

    constructor(data?: IAssistDayScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.amJob = data.amJob && !(<any>data.amJob).toJSON ? new JobDto(data.amJob) : <JobDto>this.amJob; 
            this.pmJob = data.pmJob && !(<any>data.pmJob).toJSON ? new JobDto(data.pmJob) : <JobDto>this.pmJob; 
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? moment(data["date"].toString()) : <any>null;
            this.amJob = data["amJob"] ? JobDto.fromJS(data["amJob"]) : <any>null;
            this.pmJob = data["pmJob"] ? JobDto.fromJS(data["pmJob"]) : <any>null;
            this.hasConflict = data["hasConflict"] !== undefined ? data["hasConflict"] : <any>null;
        }
    }

    static fromJS(data: any): AssistDayScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssistDayScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.format('YYYY-MM-DD') : <any>null;
        data["amJob"] = this.amJob ? this.amJob.toJSON() : <any>null;
        data["pmJob"] = this.pmJob ? this.pmJob.toJSON() : <any>null;
        data["hasConflict"] = this.hasConflict !== undefined ? this.hasConflict : <any>null;
        return data; 
    }
}

/** Jobs for an assist on one day. */
export interface IAssistDayScheduleDto {
    /** The date this schedule is for. */
    date: moment.Moment;
    /** AM job with full details. */
    amJob: IJobDto | null;
    /** PM job with full details. */
    pmJob: IJobDto | null;
    /** If this schedule has a conflict, e.g. more than two jobs a day or more than one job per time (AM/PM). */
    hasConflict: boolean;
}

/** Required details to create an account */
export class AddUserRequest implements IAddUserRequest {
    /** Email Address */
    emailAddress!: string;
    /** The UserType for the user */
    userType!: AddUserRequestUserType;
    /** If the user has UserType.Vehicle, they must be assigned to a vehicle, they can only access schedules for this vehicle. */
    vehicleId!: string | null;
    /** If the user has UserType.Field, they must be assigned to a region, they can only access schedules in this region. */
    regionId!: string | null;

    constructor(data?: IAddUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"] !== undefined ? data["emailAddress"] : <any>null;
            this.userType = data["userType"] !== undefined ? data["userType"] : <any>null;
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
            this.regionId = data["regionId"] !== undefined ? data["regionId"] : <any>null;
        }
    }

    static fromJS(data: any): AddUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["userType"] = this.userType !== undefined ? this.userType : <any>null;
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        return data; 
    }
}

/** Required details to create an account */
export interface IAddUserRequest {
    /** Email Address */
    emailAddress: string;
    /** The UserType for the user */
    userType: AddUserRequestUserType;
    /** If the user has UserType.Vehicle, they must be assigned to a vehicle, they can only access schedules for this vehicle. */
    vehicleId: string | null;
    /** If the user has UserType.Field, they must be assigned to a region, they can only access schedules in this region. */
    regionId: string | null;
}

/** Required details to register an account */
export class RegisterRequest implements IRegisterRequest {
    /** Email Address */
    emailAddress!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"] !== undefined ? data["emailAddress"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        return data; 
    }
}

/** Required details to register an account */
export interface IRegisterRequest {
    /** Email Address */
    emailAddress: string;
}

/** Information required to validate a token. */
export class ActivateAccountValidateTokenRequest implements IActivateAccountValidateTokenRequest {
    /** UserId as provided in the url in the email */
    userId!: string;
    /** Token as provided in the the url in the email */
    activationToken!: string;

    constructor(data?: IActivateAccountValidateTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.activationToken = data["activationToken"] !== undefined ? data["activationToken"] : <any>null;
        }
    }

    static fromJS(data: any): ActivateAccountValidateTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountValidateTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["activationToken"] = this.activationToken !== undefined ? this.activationToken : <any>null;
        return data; 
    }
}

/** Information required to validate a token. */
export interface IActivateAccountValidateTokenRequest {
    /** UserId as provided in the url in the email */
    userId: string;
    /** Token as provided in the the url in the email */
    activationToken: string;
}

/** Information about the validity of an account activation token. */
export class ActivateAccountValidateTokenResponse implements IActivateAccountValidateTokenResponse {
    /** If the token is still valid. */
    isValid!: boolean;

    constructor(data?: IActivateAccountValidateTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isValid = data["isValid"] !== undefined ? data["isValid"] : <any>null;
        }
    }

    static fromJS(data: any): ActivateAccountValidateTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountValidateTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid !== undefined ? this.isValid : <any>null;
        return data; 
    }
}

/** Information about the validity of an account activation token. */
export interface IActivateAccountValidateTokenResponse {
    /** If the token is still valid. */
    isValid: boolean;
}

/** Required details to activate an account */
export class ActivateRequest implements IActivateRequest {
    /** Password to assign the user, must match the password requirements */
    password!: string;
    /** UserId as provided in the url in the email */
    userId!: string;
    /** Token as provided in the the url in the email */
    activationToken!: string;

    constructor(data?: IActivateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            this.activationToken = data["activationToken"] !== undefined ? data["activationToken"] : <any>null;
        }
    }

    static fromJS(data: any): ActivateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["activationToken"] = this.activationToken !== undefined ? this.activationToken : <any>null;
        return data; 
    }
}

/** Required details to activate an account */
export interface IActivateRequest {
    /** Password to assign the user, must match the password requirements */
    password: string;
    /** UserId as provided in the url in the email */
    userId: string;
    /** Token as provided in the the url in the email */
    activationToken: string;
}

/** Details for a password reset */
export class ResetPasswordRequest implements IResetPasswordRequest {
    /** The email address associated with this request */
    email!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data; 
    }
}

/** Details for a password reset */
export interface IResetPasswordRequest {
    /** The email address associated with this request */
    email: string;
}

/** Details to confirm a password reset */
export class ResetPasswordConfirmRequest implements IResetPasswordConfirmRequest {
    /** The email address associated with this request */
    email!: string;
    /** Token as provided in email */
    token!: string;
    /** New Password to set */
    password!: string;

    constructor(data?: IResetPasswordConfirmRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.token = data["token"] !== undefined ? data["token"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordConfirmRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordConfirmRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

/** Details to confirm a password reset */
export interface IResetPasswordConfirmRequest {
    /** The email address associated with this request */
    email: string;
    /** Token as provided in email */
    token: string;
    /** New Password to set */
    password: string;
}

/** Vehicle that will perform jobs */
export class VehicleDto implements IVehicleDto {
    /** Unique ID */
    vehicleId!: string;
    /** Vehicle ID in the LIC spreadsheet
"HN01" */
    identifier!: string;
    /** Region ID of the region the vehicle is in, obtained from the LIC job spreadsheet. */
    regionId!: string | null;
    /** Start address from the LIC spreadsheet */
    startAddress!: string;
    /** Depot address (Finish location) from the LIC spreadsheet */
    depotAddress!: string;
    /** Geocoded result from StartAddress */
    startLocation!: GpsCoordinateDto | null;
    /** Geocoded result from Depot address (Finish location) */
    depotLocation!: GpsCoordinateDto | null;

    constructor(data?: IVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.startLocation = data.startLocation && !(<any>data.startLocation).toJSON ? new GpsCoordinateDto(data.startLocation) : <GpsCoordinateDto>this.startLocation; 
            this.depotLocation = data.depotLocation && !(<any>data.depotLocation).toJSON ? new GpsCoordinateDto(data.depotLocation) : <GpsCoordinateDto>this.depotLocation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
            this.identifier = data["identifier"] !== undefined ? data["identifier"] : <any>null;
            this.regionId = data["regionId"] !== undefined ? data["regionId"] : <any>null;
            this.startAddress = data["startAddress"] !== undefined ? data["startAddress"] : <any>null;
            this.depotAddress = data["depotAddress"] !== undefined ? data["depotAddress"] : <any>null;
            this.startLocation = data["startLocation"] ? GpsCoordinateDto.fromJS(data["startLocation"]) : <any>null;
            this.depotLocation = data["depotLocation"] ? GpsCoordinateDto.fromJS(data["depotLocation"]) : <any>null;
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["identifier"] = this.identifier !== undefined ? this.identifier : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["startAddress"] = this.startAddress !== undefined ? this.startAddress : <any>null;
        data["depotAddress"] = this.depotAddress !== undefined ? this.depotAddress : <any>null;
        data["startLocation"] = this.startLocation ? this.startLocation.toJSON() : <any>null;
        data["depotLocation"] = this.depotLocation ? this.depotLocation.toJSON() : <any>null;
        return data; 
    }
}

/** Vehicle that will perform jobs */
export interface IVehicleDto {
    /** Unique ID */
    vehicleId: string;
    /** Vehicle ID in the LIC spreadsheet
"HN01" */
    identifier: string;
    /** Region ID of the region the vehicle is in, obtained from the LIC job spreadsheet. */
    regionId: string | null;
    /** Start address from the LIC spreadsheet */
    startAddress: string;
    /** Depot address (Finish location) from the LIC spreadsheet */
    depotAddress: string;
    /** Geocoded result from StartAddress */
    startLocation: IGpsCoordinateDto | null;
    /** Geocoded result from Depot address (Finish location) */
    depotLocation: IGpsCoordinateDto | null;
}

/** Represents a GPS Location. WGS84 decimal format. */
export class GpsCoordinateDto implements IGpsCoordinateDto {
    /** Latitude */
    longitude!: number;
    /** Longitude */
    latitude!: number;

    constructor(data?: IGpsCoordinateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : <any>null;
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : <any>null;
        }
    }

    static fromJS(data: any): GpsCoordinateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GpsCoordinateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        return data; 
    }
}

/** Represents a GPS Location. WGS84 decimal format. */
export interface IGpsCoordinateDto {
    /** Latitude */
    longitude: number;
    /** Longitude */
    latitude: number;
}

/** Result of a Preview or Update */
export class PreviewResponse implements IPreviewResponse {
    /** Vehicle data as parsed from spreadsheet, GPS coordinates will not be set */
    parsedData!: VehicleDto[];
    /** Vehicle data after geocoding.
StartAddress / DepotAddress contain the address the geocoder returned as the match */
    geocodedData!: GeocodedVehicleDto[];

    constructor(data?: IPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.parsedData) {
                this.parsedData = [];
                for (let i = 0; i < data.parsedData.length; i++) {
                    let item = data.parsedData[i];
                    this.parsedData[i] = item && !(<any>item).toJSON ? new VehicleDto(item) : <VehicleDto>item;
                }
            }
            if (data.geocodedData) {
                this.geocodedData = [];
                for (let i = 0; i < data.geocodedData.length; i++) {
                    let item = data.geocodedData[i];
                    this.geocodedData[i] = item && !(<any>item).toJSON ? new GeocodedVehicleDto(item) : <GeocodedVehicleDto>item;
                }
            }
        }
        if (!data) {
            this.parsedData = [];
            this.geocodedData = [];
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["parsedData"])) {
                this.parsedData = [] as any;
                for (let item of data["parsedData"])
                    this.parsedData!.push(VehicleDto.fromJS(item));
            }
            if (Array.isArray(data["geocodedData"])) {
                this.geocodedData = [] as any;
                for (let item of data["geocodedData"])
                    this.geocodedData!.push(GeocodedVehicleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.parsedData)) {
            data["parsedData"] = [];
            for (let item of this.parsedData)
                data["parsedData"].push(item.toJSON());
        }
        if (Array.isArray(this.geocodedData)) {
            data["geocodedData"] = [];
            for (let item of this.geocodedData)
                data["geocodedData"].push(item.toJSON());
        }
        return data; 
    }
}

/** Result of a Preview or Update */
export interface IPreviewResponse {
    /** Vehicle data as parsed from spreadsheet, GPS coordinates will not be set */
    parsedData: IVehicleDto[];
    /** Vehicle data after geocoding.
StartAddress / DepotAddress contain the address the geocoder returned as the match */
    geocodedData: IGeocodedVehicleDto[];
}

/** VehicleDto that includes details of the quality of the geocoder match */
export class GeocodedVehicleDto implements IGeocodedVehicleDto {
    /** What level of detail the match was performed using.
Anything lower than Street, Intersection, HouseNumber is probably unsuitable */
    startMatchLevel!: GeocodedVehicleDtoStartMatchLevel;
    /** What level of detail the match was performed using.
Anything lower than Street, Intersection, HouseNumber is probably unsuitable */
    depotMatchLevel!: GeocodedVehicleDtoDepotMatchLevel;
    /** Unique ID */
    vehicleId!: string;
    /** Vehicle ID in the LIC spreadsheet
"HN01" */
    identifier!: string;
    /** Region ID of the region the vehicle is in, obtained from the LIC job spreadsheet. */
    regionId!: string | null;
    /** Start address from the LIC spreadsheet */
    startAddress!: string;
    /** Depot address (Finish location) from the LIC spreadsheet */
    depotAddress!: string;
    /** Geocoded result from StartAddress */
    startLocation!: GpsCoordinateDto | null;
    /** Geocoded result from Depot address (Finish location) */
    depotLocation!: GpsCoordinateDto | null;

    constructor(data?: IGeocodedVehicleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.startLocation = data.startLocation && !(<any>data.startLocation).toJSON ? new GpsCoordinateDto(data.startLocation) : <GpsCoordinateDto>this.startLocation; 
            this.depotLocation = data.depotLocation && !(<any>data.depotLocation).toJSON ? new GpsCoordinateDto(data.depotLocation) : <GpsCoordinateDto>this.depotLocation; 
        }
    }

    init(data?: any) {
        if (data) {
            this.startMatchLevel = data["startMatchLevel"] !== undefined ? data["startMatchLevel"] : <any>null;
            this.depotMatchLevel = data["depotMatchLevel"] !== undefined ? data["depotMatchLevel"] : <any>null;
            this.vehicleId = data["vehicleId"] !== undefined ? data["vehicleId"] : <any>null;
            this.identifier = data["identifier"] !== undefined ? data["identifier"] : <any>null;
            this.regionId = data["regionId"] !== undefined ? data["regionId"] : <any>null;
            this.startAddress = data["startAddress"] !== undefined ? data["startAddress"] : <any>null;
            this.depotAddress = data["depotAddress"] !== undefined ? data["depotAddress"] : <any>null;
            this.startLocation = data["startLocation"] ? GpsCoordinateDto.fromJS(data["startLocation"]) : <any>null;
            this.depotLocation = data["depotLocation"] ? GpsCoordinateDto.fromJS(data["depotLocation"]) : <any>null;
        }
    }

    static fromJS(data: any): GeocodedVehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeocodedVehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startMatchLevel"] = this.startMatchLevel !== undefined ? this.startMatchLevel : <any>null;
        data["depotMatchLevel"] = this.depotMatchLevel !== undefined ? this.depotMatchLevel : <any>null;
        data["vehicleId"] = this.vehicleId !== undefined ? this.vehicleId : <any>null;
        data["identifier"] = this.identifier !== undefined ? this.identifier : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["startAddress"] = this.startAddress !== undefined ? this.startAddress : <any>null;
        data["depotAddress"] = this.depotAddress !== undefined ? this.depotAddress : <any>null;
        data["startLocation"] = this.startLocation ? this.startLocation.toJSON() : <any>null;
        data["depotLocation"] = this.depotLocation ? this.depotLocation.toJSON() : <any>null;
        return data; 
    }
}

/** VehicleDto that includes details of the quality of the geocoder match */
export interface IGeocodedVehicleDto {
    /** What level of detail the match was performed using.
Anything lower than Street, Intersection, HouseNumber is probably unsuitable */
    startMatchLevel: GeocodedVehicleDtoStartMatchLevel;
    /** What level of detail the match was performed using.
Anything lower than Street, Intersection, HouseNumber is probably unsuitable */
    depotMatchLevel: GeocodedVehicleDtoDepotMatchLevel;
    /** Unique ID */
    vehicleId: string;
    /** Vehicle ID in the LIC spreadsheet
"HN01" */
    identifier: string;
    /** Region ID of the region the vehicle is in, obtained from the LIC job spreadsheet. */
    regionId: string | null;
    /** Start address from the LIC spreadsheet */
    startAddress: string;
    /** Depot address (Finish location) from the LIC spreadsheet */
    depotAddress: string;
    /** Geocoded result from StartAddress */
    startLocation: IGpsCoordinateDto | null;
    /** Geocoded result from Depot address (Finish location) */
    depotLocation: IGpsCoordinateDto | null;
}

/** The type of notification to get. If parameter is not provided, all types will be fetched. */
export enum Type {
    AheadOfTimeHerdTestNotice = "AheadOfTimeHerdTestNotice",
    OnWay = "OnWay",
    AssistSchedule = "AssistSchedule",
}

export enum NotificationRunType {
    AheadOfTimeHerdTestNotice = "AheadOfTimeHerdTestNotice",
    OnWay = "OnWay",
    AssistSchedule = "AssistSchedule",
}

export enum UserTypes {
    Admin = "Admin",
    Vehicle = "Vehicle",
    Operations = "Operations",
    Field = "Field",
    Torutek = "Torutek",
    Assist = "Assist",
}

export enum RecordLocationRequestLocationType {
    ShedEntrance = "ShedEntrance",
    PropertyEntrance = "PropertyEntrance",
}

export enum NotificationLogDtoType {
    AheadOfTimeHerdTestNotice = "AheadOfTimeHerdTestNotice",
    OnWay = "OnWay",
    AssistSchedule = "AssistSchedule",
}

export enum NotificationLogDtoMethod {
    Sms = "Sms",
    Email = "Email",
}

export enum NotificationRunDtoType {
    AheadOfTimeHerdTestNotice = "AheadOfTimeHerdTestNotice",
    OnWay = "OnWay",
    AssistSchedule = "AssistSchedule",
}

export enum JobDtoJobType {
    Deliver = "Deliver",
    Pickup = "Pickup",
}

export enum JobDetailsDtoSamplingRegime {
    Am = "Am",
    Pm = "Pm",
    PmAndAm = "PmAndAm",
}

export enum AddUserRequestUserType {
    Admin = "Admin",
    Vehicle = "Vehicle",
    Operations = "Operations",
    Field = "Field",
    Torutek = "Torutek",
    Assist = "Assist",
}

export enum GeocodedVehicleDtoStartMatchLevel {
    Country = "Country",
    State = "State",
    County = "County",
    City = "City",
    District = "District",
    Street = "Street",
    Intersection = "Intersection",
    HouseNumber = "HouseNumber",
    PostalCode = "PostalCode",
    Landmark = "Landmark",
}

export enum GeocodedVehicleDtoDepotMatchLevel {
    Country = "Country",
    State = "State",
    County = "County",
    City = "City",
    District = "District",
    Street = "Street",
    Intersection = "Intersection",
    HouseNumber = "HouseNumber",
    PostalCode = "PostalCode",
    Landmark = "Landmark",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}